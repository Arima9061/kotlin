MODULE_FRAGMENT name:<main>
  FILE fqName:<root> fileName:/kt52270.kt
    FUN name:fun1 signature:/fun1|fun1(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
    FUN name:fun2 signature:/fun2|fun2(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
    FUN name:takesLambda signature:/takesLambda|takesLambda(kotlin.Function0<kotlin.Unit>){}[0] visibility:public modality:FINAL <> (lambda:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>) returnType:<unbound IrClassSymbolImpl>
      VALUE_PARAMETER name:lambda index:0 type:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>
      BLOCK_BODY
        CALL 'UNBOUND IrSimpleFunctionSymbolImpl' type=<unbound IrClassSymbolImpl> origin=INVOKE
          $this: GET_VAR 'lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> declared in <root>.takesLambda' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=VARIABLE_AS_FUNCTION
    FUN name:takesOtherLambda signature:/takesOtherLambda|takesOtherLambda(kotlin.Function0<kotlin.Unit>){}[0] visibility:public modality:FINAL <> (lambda:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>) returnType:<unbound IrClassSymbolImpl>
      VALUE_PARAMETER name:lambda index:0 type:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>
      BLOCK_BODY
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun takesOtherLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>'
          CALL 'UNBOUND IrSimpleFunctionSymbolImpl' type=<unbound IrClassSymbolImpl> origin=INVOKE
            $this: GET_VAR 'lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> declared in <root>.takesOtherLambda' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=VARIABLE_AS_FUNCTION
    FUN name:foo signature:/foo|foo(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
    FUN name:bar2 signature:/bar2|bar2(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun bar2 (): <unbound IrClassSymbolImpl> declared in <root>'
          CONST Int type=<unbound IrClassSymbolImpl> value=1
    FUN name:foo4 signature:/foo4|foo4(){0ยง<kotlin.Any?>}[0] visibility:public modality:FINAL <K> () returnType:K of <root>.foo4
      TYPE_PARAMETER name:K index:0 variance: signature:[ /foo4|foo4(){0ยง<kotlin.Any?>}[0] <- Local[<TP>,0|TYPE_PARAMETER name:K index:0 variance: superTypes:[kotlin.Any?] reified:false] ] superTypes:[<unbound IrClassSymbolImpl>?] reified:false
      BLOCK_BODY
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun foo4 <K> (): K of <root>.foo4 declared in <root>'
          TYPE_OP type=K of <root>.foo4 origin=CAST typeOperand=K of <root>.foo4
            CONST Int type=<unbound IrClassSymbolImpl> value=2
    FUN name:test1 signature:/test1|test1(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
        CALL 'public final fun takesOtherLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
          lambda: FUN_EXPR type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=LAMBDA
            FUN LOCAL_FUNCTION_FOR_LAMBDA name:<anonymous> visibility:local modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
              BLOCK_BODY
                VAR name:reference type:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val]
                  WHEN type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=IF
                    BRANCH
                      if: CALL 'UNBOUND IrSimpleFunctionSymbolImpl' type=<unbound IrClassSymbolImpl> origin=null
                        $this: GET_OBJECT 'UNBOUND IrClassSymbolImpl' type=<unbound IrClassSymbolImpl>
                      then: BLOCK type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
                        FUNCTION_REFERENCE 'public final fun fun1 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                    BRANCH
                      if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
                      then: BLOCK type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
                        FUNCTION_REFERENCE 'public final fun fun2 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                CALL 'public final fun takesLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                  lambda: GET_VAR 'val reference: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val] declared in <root>.test1.<anonymous>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun test1 (): <unbound IrClassSymbolImpl> declared in <root>'
          CONST String type=<unbound IrClassSymbolImpl> value="OK"
    FUN name:test2 signature:/test2|test2(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
        CALL 'public final fun takesOtherLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
          lambda: FUN_EXPR type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=LAMBDA
            FUN LOCAL_FUNCTION_FOR_LAMBDA name:<anonymous> visibility:local modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
              BLOCK_BODY
                VAR name:reference type:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val]
                  WHEN type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=IF
                    BRANCH
                      if: CALL 'UNBOUND IrSimpleFunctionSymbolImpl' type=<unbound IrClassSymbolImpl> origin=null
                        $this: GET_OBJECT 'UNBOUND IrClassSymbolImpl' type=<unbound IrClassSymbolImpl>
                      then: FUNCTION_REFERENCE 'public final fun fun1 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                    BRANCH
                      if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
                      then: FUNCTION_REFERENCE 'public final fun fun2 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                CALL 'public final fun takesLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                  lambda: GET_VAR 'val reference: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val] declared in <root>.test2.<anonymous>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun test2 (): <unbound IrClassSymbolImpl> declared in <root>'
          CONST String type=<unbound IrClassSymbolImpl> value="OK"
    FUN name:test3 signature:/test3|test3(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
        CALL 'public final fun takesOtherLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
          lambda: FUN_EXPR type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=LAMBDA
            FUN LOCAL_FUNCTION_FOR_LAMBDA name:<anonymous> visibility:local modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
              BLOCK_BODY
                VAR name:reference type:<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val]
                  WHEN type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=IF
                    BRANCH
                      if: CALL 'UNBOUND IrSimpleFunctionSymbolImpl' type=<unbound IrClassSymbolImpl> origin=null
                        $this: GET_OBJECT 'UNBOUND IrClassSymbolImpl' type=<unbound IrClassSymbolImpl>
                      then: BLOCK type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
                        CALL 'public final fun foo (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                        FUNCTION_REFERENCE 'public final fun fun1 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                    BRANCH
                      if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
                      then: BLOCK type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
                        CALL 'public final fun foo (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                        FUNCTION_REFERENCE 'public final fun fun2 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null reflectionTarget=<same>
                CALL 'public final fun takesLambda (lambda: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>>): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                  lambda: GET_VAR 'val reference: <unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> [val] declared in <root>.test3.<anonymous>' type=<unbound IrClassSymbolImpl><<unbound IrClassSymbolImpl>> origin=null
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun test3 (): <unbound IrClassSymbolImpl> declared in <root>'
          CONST String type=<unbound IrClassSymbolImpl> value="OK"
    FUN name:box signature:/box|box(){}[0] visibility:public modality:FINAL <> () returnType:<unbound IrClassSymbolImpl>
      BLOCK_BODY
        RETURN type=<unbound IrClassSymbolImpl> from='public final fun box (): <unbound IrClassSymbolImpl> declared in <root>'
          WHEN type=<unbound IrClassSymbolImpl> origin=IF
            BRANCH
              if: WHEN type=<unbound IrClassSymbolImpl> origin=ANDAND
                BRANCH
                  if: WHEN type=<unbound IrClassSymbolImpl> origin=ANDAND
                    BRANCH
                      if: CALL 'public final fun EQEQ (arg0: <unbound IrClassSymbolImpl>?, arg1: <unbound IrClassSymbolImpl>?): <unbound IrClassSymbolImpl> declared in kotlin.internal.ir' type=<unbound IrClassSymbolImpl> origin=EQEQ
                        arg0: CALL 'public final fun test1 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                        arg1: CONST String type=<unbound IrClassSymbolImpl> value="OK"
                      then: CALL 'public final fun EQEQ (arg0: <unbound IrClassSymbolImpl>?, arg1: <unbound IrClassSymbolImpl>?): <unbound IrClassSymbolImpl> declared in kotlin.internal.ir' type=<unbound IrClassSymbolImpl> origin=EQEQ
                        arg0: CALL 'public final fun test2 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                        arg1: CONST String type=<unbound IrClassSymbolImpl> value="OK"
                    BRANCH
                      if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
                      then: CONST Boolean type=<unbound IrClassSymbolImpl> value=false
                  then: CALL 'public final fun EQEQ (arg0: <unbound IrClassSymbolImpl>?, arg1: <unbound IrClassSymbolImpl>?): <unbound IrClassSymbolImpl> declared in kotlin.internal.ir' type=<unbound IrClassSymbolImpl> origin=EQEQ
                    arg0: CALL 'public final fun test3 (): <unbound IrClassSymbolImpl> declared in <root>' type=<unbound IrClassSymbolImpl> origin=null
                    arg1: CONST String type=<unbound IrClassSymbolImpl> value="OK"
                BRANCH
                  if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
                  then: CONST Boolean type=<unbound IrClassSymbolImpl> value=false
              then: CONST String type=<unbound IrClassSymbolImpl> value="OK"
            BRANCH
              if: CONST Boolean type=<unbound IrClassSymbolImpl> value=true
              then: CONST String type=<unbound IrClassSymbolImpl> value="NOK"
