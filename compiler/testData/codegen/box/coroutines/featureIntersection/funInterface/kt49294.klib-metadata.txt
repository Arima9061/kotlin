library {
  // module name: <main>

  library fragment {
    // package name: <root>

    // class name: ChannelFlow
    // class name: ChannelFlowBuilder
    // class name: ChannelFlowMerge
    // class name: Flow
    // class name: FlowCollector
    // class name: SafeFlow
    // class name: SendChannel

    public abstract class ChannelFlow<T#0 /* T */> : Flow<T#0> {

      public constructor()

      public open suspend fun collect(collector: FlowCollector<T#0>): kotlin/Unit

      protected abstract suspend fun collectTo(scope: SendChannel<T#0>): kotlin/Unit
    }

    private open class ChannelFlowBuilder<T#0 /* T */> : ChannelFlow<T#0> {

      public constructor(block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<SendChannel<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>)

      protected open suspend fun collectTo(scope: SendChannel<T#0>): kotlin/Unit

      private final val block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<SendChannel<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>
        private final get
    }

    public final class ChannelFlowMerge<T#0 /* T */> : ChannelFlow<T#0> {

      public constructor(flow: Flow<Flow<T#0>>)

      protected open suspend fun collectTo(scope: SendChannel<T#0>): kotlin/Unit

      public final val flow: Flow<Flow<T#0>>
        public final get
    }

    public abstract interface Flow<out T#0 /* T */> : kotlin/Any {

      public abstract suspend fun collect(collector: FlowCollector<T#0>): kotlin/Unit
    }

    public abstract fun interface FlowCollector<in T#0 /* T */> : kotlin/Any {

      public abstract suspend fun emit(value: T#0): kotlin/Unit
    }

    private final class SafeFlow<T#0 /* T */> : Flow<T#0> {

      public constructor(block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<FlowCollector<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>)

      public open suspend fun collect(collector: FlowCollector<T#0>): kotlin/Unit

      private final val block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<FlowCollector<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>
        private final get
    }

    public abstract interface SendChannel<in T#0 /* E */> : kotlin/Any {

      public abstract suspend fun send(element: T#0): kotlin/Unit
    }

    package {

      public final fun box(): kotlin/String

      public final fun <T#0 /* T */> channelFlow(block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<SendChannel<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>): Flow<T#0>

      public final fun <T#0 /* T */, T#1 /* R */> Flow<T#0>.flatMapMerge(transform: suspend kotlin/Function2<@kotlin/ParameterName(name = "value") T#0, kotlin/coroutines/Continuation<Flow<T#1>>, kotlin/Any?>): Flow<T#1>

      public final fun <T#0 /* T */> Flow<Flow<T#0>>.flattenMerge(): Flow<T#0>

      public final fun <T#0 /* T */> flow(block: @kotlin/ExtensionFunctionType suspend kotlin/Function2<FlowCollector<T#0>, kotlin/coroutines/Continuation<kotlin/Unit>, kotlin/Any?>): Flow<T#0>

      public final inline fun <T#0 /* T */, T#1 /* R */> Flow<T#0>.map(crossinline transform: suspend kotlin/Function2<@kotlin/ParameterName(name = "value") T#0, kotlin/coroutines/Continuation<T#1>, kotlin/Any?>): Flow<T#1>

      public final suspend fun <T#0 /* T */> Flow<T#0>.toList(): kotlin/collections/List<T#0>
    }
  }
}
