// CHECK:
//   Mangled name: I1
//   Public signature: /I1|null[0]
interface I1 {

}

// CHECK:
//   Mangled name: I2
//   Public signature: /I2|null[0]
interface I2 {

}

// CHECK JVM_IR:
//   Mangled name: #component1@I1(){}kotlin.Int
//   Public signature: /component1|8801376328143328436[0]
// CHECK JS_IR:
//   Mangled name computed from Ir:         #component1@I1(){}
//   Mangled name computed from Descriptor: #component1@I1(){}
//   Mangled name computed from Fir:        #component1@I1(){}kotlin.Int
//   Public signature: /component1|8801376328143328436[0]
operator fun I1.component1(): Int {
  return 1
}

// CHECK JVM_IR:
//   Mangled name: #component2@I2(){}kotlin.String
//   Public signature: /component2|-3393912940495634771[0]
// CHECK JS_IR:
//   Mangled name computed from Ir:         #component2@I2(){}
//   Mangled name computed from Descriptor: #component2@I2(){}
//   Mangled name computed from Fir:        #component2@I2(){}kotlin.String
//   Public signature: /component2|-3393912940495634771[0]
operator fun I2.component2(): String {
  return ""
}

// CHECK JVM_IR:
//   Mangled name: #test(I1){}
//   Public signature: /test|-2567635956051433615[0]
// CHECK JS_IR:
//   Mangled name: #test(I1){}
//   Public signature: /test|-2567635956051433615[0]
fun test(x: I1) {
  when {
    x !is I2 -> return Unit
  }
  val <destruct>: I1 = x /*as I2 */
  val c1: Int = <destruct> /*as I2 */.component1()
  val c2: String = <destruct> /*as I2 */.component2()
}

