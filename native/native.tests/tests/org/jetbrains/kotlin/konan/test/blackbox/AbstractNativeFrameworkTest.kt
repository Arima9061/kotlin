/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.konan.test.blackbox

import com.intellij.testFramework.TestDataFile
import org.jetbrains.kotlin.cli.common.ExitCode
import org.jetbrains.kotlin.konan.test.blackbox.support.*
import org.jetbrains.kotlin.konan.test.blackbox.support.PackageName
import org.jetbrains.kotlin.konan.test.blackbox.support.TestCase
import org.jetbrains.kotlin.konan.test.blackbox.support.TestCaseId
import org.jetbrains.kotlin.konan.test.blackbox.support.TestCompilerArgs
import org.jetbrains.kotlin.konan.test.blackbox.support.TestFile
import org.jetbrains.kotlin.konan.test.blackbox.support.TestKind
import org.jetbrains.kotlin.konan.test.blackbox.support.TestModule
import org.jetbrains.kotlin.konan.test.blackbox.support.compilation.TestCompilationArtifact
import org.jetbrains.kotlin.konan.test.blackbox.support.compilation.TestCompilationFactory
import org.jetbrains.kotlin.konan.test.blackbox.support.compilation.TestCompilationResult
import org.jetbrains.kotlin.konan.test.blackbox.support.compilation.TestCompilationResult.Companion.assertSuccess
import org.jetbrains.kotlin.konan.test.blackbox.support.runner.TestExecutable
import org.jetbrains.kotlin.konan.test.blackbox.support.runner.TestRunChecks
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.KotlinNativeTargets
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.Timeouts
import org.jetbrains.kotlin.konan.test.blackbox.support.util.DEFAULT_MODULE_NAME
import org.jetbrains.kotlin.konan.test.blackbox.support.util.codesign
import org.jetbrains.kotlin.konan.test.blackbox.support.util.compileWithSwiftc
import org.jetbrains.kotlin.konan.test.blackbox.support.util.getAbsoluteFile
import org.junit.jupiter.api.Assumptions
import org.junit.jupiter.api.Tag
import java.io.File
import java.io.FileWriter

@Tag("framework")
abstract class AbstractNativeFrameworkTest : AbstractNativeSimpleTest() {

    private val targets: KotlinNativeTargets get() = testRunSettings.get<KotlinNativeTargets>()
    private val testCompilationFactory = TestCompilationFactory()

    protected fun runTest(@TestDataFile testDir: String) {
        Assumptions.assumeTrue(targets.testTarget.family.isAppleFamily)
        val testPathFull = getAbsoluteFile(testDir)
        val ktSources = testPathFull.list()!!
            .filter { it.endsWith(".kt") }
            .map { testPathFull.resolve(it) }
        ktSources.forEach { muteTestIfNecessary(it) }

        val testCase: TestCase = generateObjCFrameworkTestCase(testPathFull, ktSources)
        val objCFramework: TestCompilationArtifact.ObjCFramework = testCase.toObjCFramework().assertSuccess().resultingArtifact
        val codesignLoggedData = codesign(objCFramework.frameworkDir)
        Assumptions.assumeTrue(codesignLoggedData.exitCode == ExitCode.OK)

        val swiftSources = testPathFull.list()!!
            .filter { it.endsWith(".swift") }
            .map { testPathFull.resolve(it) }

        // TODO: Cache between tests.
        val testFrameworkFile: File = run {
            val result = File(buildDir, "main.swift")
            val inputStream = AbstractNativeFrameworkTest::class.java.getResourceAsStream("/swift/main.swift")
                ?: error("Could not find Swift testing framework sources")
            inputStream.bufferedReader().use { reader ->
                reader.lineSequence().forEach { line ->
                    result.appendText(line + "\n")
                }
            }
            result
        }
        val providerFile: File = run {
            val result = File(buildDir, "provider.swift")
            val providers = swiftSources.map { it.nameWithoutExtension.replaceFirstChar { it.uppercase() } }
                .map { "${it}Tests" }
            FileWriter(result).use { writer ->
                writer.write("""
                |// THIS IS AUTOGENERATED FILE
                |// This method is invoked by the main routine to get a list of tests
                |func registerProviders() {
                |    ${providers.joinToString("\n    ") { "$it()" }}
                |}
                """.trimMargin())
            }
            result
        }

        val mainExecutableName = "swiftMain"
        val mainExecutable = File(buildDir, mainExecutableName)
        val swiftcResult = compileWithSwiftc(
            outputFile = mainExecutable,
            sources = swiftSources + listOf(testFrameworkFile, providerFile),
            frameworkDirectories = listOf(objCFramework.frameworkDir.parentFile),
            rpaths = listOf("@executable_path/Frameworks", objCFramework.frameworkDir.parentFile.absolutePath)
        ).assertSuccess()

        val testExecutable = TestExecutable(
            swiftcResult.resultingArtifact,
            loggedCompilationToolCall = swiftcResult.loggedData,
            testNames = listOf(TestName("TMP")),
        )
        runExecutableAndVerify(testCase, testExecutable)
    }

    private fun TestCase.toObjCFramework(): TestCompilationResult<out TestCompilationArtifact.ObjCFramework> {
        return testCompilationFactory.testCaseToObjCFrameworkCompilation(this, testRunSettings).result
    }

    private fun generateObjCFrameworkTestCase(testPathFull: File, sources: List<File>): TestCase {
        val moduleName: String = testPathFull.name
        val module = TestModule.Exclusive(DEFAULT_MODULE_NAME, emptySet(), emptySet(), emptySet())
        sources.forEach { module.files += TestFile.createCommitted(it, module) }

        return TestCase(
            id = TestCaseId.Named(moduleName),
            kind = TestKind.STANDALONE_NO_TR,
            modules = setOf(module),
            freeCompilerArgs = TestCompilerArgs(listOf("-Xexport-kdoc")),
            nominalPackageName = PackageName(moduleName),
            checks = TestRunChecks.Default(testRunSettings.get<Timeouts>().executionTimeout),
            extras = TestCase.NoTestRunnerExtras(entryPoint = "main")
        ).apply {
            initialize(null, null)
        }
    }
}