KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<UNRESOLVED_REFERENCE_WRONG_RECEIVER: Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
  fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.Array<out kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <T, K> kotlin/Array<out T>.kotlin/collections/groupBy(keySelector: (T) -> K): kotlin/collections/Map<K, kotlin/collections/List<T>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.Array<out kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.collections.IndexedValue<kotlin.Int>>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/BooleanArray.kotlin/collections/groupBy(keySelector: (kotlin/Boolean) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Boolean>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.BooleanArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Boolean>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Boolean>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.BooleanArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>, valueTransform: kotlin.Function1<kotlin.Boolean, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/ByteArray.kotlin/collections/groupBy(keySelector: (kotlin/Byte) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Byte>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ByteArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Byte>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Byte>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ByteArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>, valueTransform: kotlin.Function1<kotlin.Byte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/CharArray.kotlin/collections/groupBy(keySelector: (kotlin/Char) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Char>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Char>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/CharSequence.kotlin/text/groupBy(keySelector: (kotlin/Char) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Char>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharSequence
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Char>>
        symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/text/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharSequence
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/text/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/DoubleArray.kotlin/collections/groupBy(keySelector: (kotlin/Double) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Double>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.DoubleArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Double>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Double>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Double, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Double, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.DoubleArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>, valueTransform: kotlin.Function1<kotlin.Double, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Double, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Double, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/FloatArray.kotlin/collections/groupBy(keySelector: (kotlin/Float) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Float>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.FloatArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Float>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Float>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Float, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Float, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.FloatArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>, valueTransform: kotlin.Function1<kotlin.Float, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Float, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Float, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/IntArray.kotlin/collections/groupBy(keySelector: (kotlin/Int) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Int>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.IntArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Int, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Int, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.IntArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>, valueTransform: kotlin.Function1<kotlin.Int, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Int, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Int, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.LongArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>, valueTransform: kotlin.Function1<kotlin.Long, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Long, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Long, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/LongArray.kotlin/collections/groupBy(keySelector: (kotlin/Long) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Long>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.LongArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Long>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Long>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Long, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Long, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ShortArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>, valueTransform: kotlin.Function1<kotlin.Short, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Short, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Short, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/ShortArray.kotlin/collections/groupBy(keySelector: (kotlin/Short) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/Short>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ShortArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Short>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Short>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Short, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Short, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun <K, V> @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UByteArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>, valueTransform: kotlin.Function1<kotlin.UByte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/UByteArray.kotlin/collections/groupBy(keySelector: (kotlin/UByte) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/UByte>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UByteArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.UByte>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UByte>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun <K, V> @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UIntArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>, valueTransform: kotlin.Function1<kotlin.UInt, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/UIntArray.kotlin/collections/groupBy(keySelector: (kotlin/UInt) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/UInt>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UIntArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.UInt>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UInt>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun <K, V> @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ULongArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>, valueTransform: kotlin.Function1<kotlin.ULong, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/ULongArray.kotlin/collections/groupBy(keySelector: (kotlin/ULong) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/ULong>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ULongArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.ULong>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.ULong>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun <K, V> @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UShortArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>, valueTransform: kotlin.Function1<kotlin.UShort, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <K> kotlin/UShortArray.kotlin/collections/groupBy(keySelector: (kotlin/UShort) -> K): kotlin/collections/Map<K, kotlin/collections/List<kotlin/UShort>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UShortArray
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.UShort>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UShort>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtApplicableCallCandidateInfo:
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = true

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <T, K> kotlin/collections/Iterable<T>.kotlin/collections/groupBy(keySelector: (T) -> K): kotlin/collections/Map<K, kotlin/collections/List<T>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.collections.IndexedValue<kotlin.Int>>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun <K> List<Pair<Int, Int>>.groupBy(keySelector: (Pair<Int, Int>) -> K, valueTransform: (Pair<Int, Int>) -> Int): Map<K, List<Int>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.collections.List<kotlin.Int>>
        symbol = /groupBy(<extension receiver>: kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>, keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>, valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.collections.IndexedValue<kotlin.Int>>
            symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = /groupBy
    typeArgumentsMapping = {
      K -> (kotlin.collections.IndexedValue<kotlin.Int>)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.collections.IndexedValue<kotlin.Int>>
        symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<UNRESOLVED_REFERENCE_WRONG_RECEIVER: Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
  fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>>>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.sequences.Sequence<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/sequences/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int),
      V -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for 'public final inline fun <T, K> kotlin/sequences/Sequence<T>.kotlin/sequences/groupBy(keySelector: (T) -> K): kotlin/collections/Map<K, kotlin/collections/List<T>>'.>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.sequences.Sequence<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.collections.IndexedValue<kotlin.Int>>>
        symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/sequences/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (kotlin.Int)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false