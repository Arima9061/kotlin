KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<UNRESOLVED_REFERENCE_WRONG_RECEIVER: Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
  fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.Array<out kotlin.Int>
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.Array<out T>, action: kotlin.Function1<T, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = action: kotlin.Function1<T, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {
      T -> (kotlin.Int)
    }
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = action: kotlin.Function1<T, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.BooleanArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.BooleanArray, action: kotlin.Function1<kotlin.Boolean, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Boolean, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Boolean, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun ByteArray.forEach(action: (Byte) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ByteArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.ByteArray, action: kotlin.Function1<kotlin.Byte, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Byte, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Byte, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun CharArray.forEach(action: (Char) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.CharArray, action: kotlin.Function1<kotlin.Char, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Char, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Char, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun CharSequence.forEach(action: (Char) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharSequence
        returnType = kotlin.Unit
        symbol = kotlin/text/forEach(<extension receiver>: kotlin.CharSequence, action: kotlin.Function1<kotlin.Char, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Char, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/text/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Char, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun DoubleArray.forEach(action: (Double) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.DoubleArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.DoubleArray, action: kotlin.Function1<kotlin.Double, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Double, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Double, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun FloatArray.forEach(action: (Float) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.FloatArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.FloatArray, action: kotlin.Function1<kotlin.Float, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Float, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Float, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun IntArray.forEach(action: (Int) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.IntArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.IntArray, action: kotlin.Function1<kotlin.Int, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Int, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Int, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun LongArray.forEach(action: (Long) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.LongArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.LongArray, action: kotlin.Function1<kotlin.Long, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Long, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Long, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun ShortArray.forEach(action: (Short) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ShortArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.ShortArray, action: kotlin.Function1<kotlin.Short, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Short, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Short, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UByteArray.forEach(action: (UByte) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UByteArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.UByteArray, action: kotlin.Function1<kotlin.UByte, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.UByte, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.UByte, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UIntArray.forEach(action: (UInt) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UIntArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.UIntArray, action: kotlin.Function1<kotlin.UInt, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.UInt, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.UInt, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() ULongArray.forEach(action: (ULong) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ULongArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.ULongArray, action: kotlin.Function1<kotlin.ULong, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.ULong, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.ULong, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @SinceKotlin(...) @ExperimentalUnsignedTypes() @InlineOnly() fun @receiver:SinceKotlin(...) @receiver:ExperimentalUnsignedTypes() @receiver:InlineOnly() UShortArray.forEach(action: (UShort) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UShortArray
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.UShortArray, action: kotlin.Function1<kotlin.UShort, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.UShort, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.UShort, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtApplicableCallCandidateInfo:
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterable<kotlin.Int>
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.collections.Iterable<T>, action: kotlin.Function1<T, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = action: kotlin.Function1<T, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {
      T -> (kotlin.Int)
    }
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = action: kotlin.Function1<T, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = true

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<UNRESOLVED_REFERENCE_WRONG_RECEIVER: Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
  fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterator<kotlin.Int>
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.collections.Iterator<T>, operation: kotlin.Function1<T, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = operation
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = operation: kotlin.Function1<T, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {
      T -> (kotlin.Int)
    }
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = operation
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = operation: kotlin.Function1<T, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): fun List<Int>.forEach(action: (Int) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.List<kotlin.Int>
        returnType = kotlin.Unit
        symbol = /forEach(<extension receiver>: kotlin.collections.List<kotlin.Int>, action: kotlin.Function1<kotlin.Int, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.Int, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = /forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.Int, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<INAPPLICABLE_CANDIDATE: Inapplicable candidate(s): @HidesMembers() fun <K, V> @receiver:HidesMembers() Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Map<out kotlin.Int, V>
        returnType = kotlin.Unit
        symbol = kotlin/collections/forEach(<extension receiver>: kotlin.collections.Map<out K, V>, action: kotlin.Function1<kotlin.collections.Map.Entry<K, V>, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.Map.Entry<kotlin.Int, V>, kotlin.Unit>
            symbol = action: kotlin.Function1<kotlin.collections.Map.Entry<K, V>, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/forEach
    typeArgumentsMapping = {}
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.Map.Entry<kotlin.Int, V>, kotlin.Unit>
        symbol = action: kotlin.Function1<kotlin.collections.Map.Entry<K, V>, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<UNRESOLVED_REFERENCE_WRONG_RECEIVER: Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
  fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = listOf(1, 2, 3)
        isSafeNavigation = false
        type = kotlin.collections.List<kotlin.Int>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.sequences.Sequence<kotlin.Int>
        returnType = kotlin.Unit
        symbol = kotlin/sequences/forEach(<extension receiver>: kotlin.sequences.Sequence<T>, action: kotlin.Function1<T, kotlin.Unit>): kotlin.Unit
        valueParameters = [
          KtVariableLikeSignature:
            name = action
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
            symbol = action: kotlin.Function1<T, kotlin.Unit>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/sequences/forEach
    typeArgumentsMapping = {
      T -> (kotlin.Int)
    }
    argumentMapping = {
      { } -> (KtVariableLikeSignature:
        name = action
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, kotlin.Unit>
        symbol = action: kotlin.Function1<T, kotlin.Unit>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false