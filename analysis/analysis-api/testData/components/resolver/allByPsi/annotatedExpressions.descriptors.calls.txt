KtAnnotationEntry(23,59): '@Target(AnnotationTarget.EXPRESSION)'
  KtAnnotationCall:
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = kotlin.annotation.Target
        symbol = <constructor>(vararg allowedTargets: kotlin.annotation.AnnotationTarget): kotlin.annotation.Target
        valueParameters = [
          KtVariableLikeSignature:
            name = allowedTargets
            receiverType = null
            returnType = kotlin.annotation.AnnotationTarget
            symbol = vararg allowedTargets: kotlin.annotation.AnnotationTarget
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = null
    typeArgumentsMapping = {}
    argumentMapping = {
      AnnotationTarget.EXPRESSION -> (KtVariableLikeSignature:
        name = allowedTargets
        receiverType = null
        returnType = kotlin.annotation.AnnotationTarget
        symbol = vararg allowedTargets: kotlin.annotation.AnnotationTarget
        callableIdIfNonLocal = null)
    }

KtAnnotationEntry(60,98): '@Retention(AnnotationRetention.SOURCE)'
  KtAnnotationCall:
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = kotlin.annotation.Retention
        symbol = <constructor>(value: kotlin.annotation.AnnotationRetention): kotlin.annotation.Retention
        valueParameters = [
          KtVariableLikeSignature:
            name = value
            receiverType = null
            returnType = kotlin.annotation.AnnotationRetention
            symbol = value: kotlin.annotation.AnnotationRetention
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = null
    typeArgumentsMapping = {}
    argumentMapping = {
      AnnotationRetention.SOURCE -> (KtVariableLikeSignature:
        name = value
        receiverType = null
        returnType = kotlin.annotation.AnnotationRetention
        symbol = value: kotlin.annotation.AnnotationRetention
        callableIdIfNonLocal = null)
    }

KtAnnotationEntry(157,175): '@Anno(0 + integer)'
  KtAnnotationCall:
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = Anno
        symbol = <constructor>(number: kotlin.Int): Anno
        valueParameters = [
          KtVariableLikeSignature:
            name = number
            receiverType = null
            returnType = kotlin.Int
            symbol = number: kotlin.Int
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = null
    typeArgumentsMapping = {}
    argumentMapping = {
      0 + integer -> (KtVariableLikeSignature:
        name = number
        receiverType = null
        returnType = kotlin.Int
        symbol = number: kotlin.Int
        callableIdIfNonLocal = null)
    }

KtOperationReferenceExpression(165,166): '+'
  KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = KtExplicitReceiverValue:
        expression = 0
        isSafeNavigation = false
        type = kotlin.Int
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = kotlin.Int
        symbol = kotlin/Int.plus(<dispatch receiver>: kotlin.Int, other: kotlin.Int): kotlin.Int
        valueParameters = [
          KtVariableLikeSignature:
            name = other
            receiverType = null
            returnType = kotlin.Int
            symbol = other: kotlin.Int
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/Int.plus
    typeArgumentsMapping = {}
    argumentMapping = {
      integer -> (KtVariableLikeSignature:
        name = other
        receiverType = null
        returnType = kotlin.Int
        symbol = other: kotlin.Int
        callableIdIfNonLocal = null)
    }

KtAnnotationEntry(177,191): '@Anno(integer)'
  KtAnnotationCall:
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = Anno
        symbol = <constructor>(number: kotlin.Int): Anno
        valueParameters = [
          KtVariableLikeSignature:
            name = number
            receiverType = null
            returnType = kotlin.Int
            symbol = number: kotlin.Int
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = null
    typeArgumentsMapping = {}
    argumentMapping = {
      integer -> (KtVariableLikeSignature:
        name = number
        receiverType = null
        returnType = kotlin.Int
        symbol = number: kotlin.Int
        callableIdIfNonLocal = null)
    }

KtCallExpression(192,199): 'usage()'
  KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = kotlin.Unit
        symbol = /usage(): kotlin.Unit
        valueParameters = []
        callableIdIfNonLocal = /usage
    typeArgumentsMapping = {}
    argumentMapping = {}

KtCallExpression(201,211): 'toString()'
  KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = KtExplicitReceiverValue:
        expression = (@Anno(integer) usage())
        isSafeNavigation = false
        type = kotlin.Unit
      extensionReceiver = null
      signature = KtFunctionLikeSignature:
        receiverType = null
        returnType = kotlin.String
        symbol = kotlin/Unit.toString(<dispatch receiver>: kotlin.Unit): kotlin.String
        valueParameters = []
        callableIdIfNonLocal = kotlin/Unit.toString
    typeArgumentsMapping = {}
    argumentMapping = {}

